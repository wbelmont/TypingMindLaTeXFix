(() => {
if (window.__tm_katex_done) return;
window.__tm_katex_done = true;

function injectCSS(h){ const l=document.createElement('link'); l.rel='stylesheet'; l.href=h; document.head.appendChild(l); }
function injectJS(h, cb){ const s=document.createElement('script'); s.src=h; s.async=true; s.onload=cb; document.head.appendChild(s); }

function sanitizeTextNodes(root){
const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
acceptNode: function(node){
const p=node.parentNode;
if(!p) return NodeFilter.FILTER_REJECT;
const skip = /^(SCRIPT|STYLE|TEXTAREA|CODE|PRE|IFRAME)$/i;
if(skip.test(p.tagName)) return NodeFilter.FILTER_REJECT;
if(!node.nodeValue || !node.nodeValue.trim()) return NodeFilter.FILTER_REJECT;
return NodeFilter.FILTER_ACCEPT;
}
});
let n;
while(n=walker.nextNode()){
let s=n.nodeValue;
const ns = s
.replace(/\$/g, '$') // $ -> $
.replace(/\$$[A-Za-z])/g, '\$1')// \x -> \x
.replace(/&#36;|$/g, '$'); // HTML-escaped $
if(ns !== s) n.nodeValue = ns;
}
}

function doRender(){
sanitizeTextNodes(document.body);
const DELIMS = [
{left: '
′
,
r
i
g
h
t
:
′
′
 ,right: 
′
 ', display: true},
{left: '$$', right: '$$', display: true},
{left: '\(', right: '$$', display: false},
{left: '$', right: '$', display: false}
];
const IGNORE = ['script','noscript','style','textarea','pre','code'];

if(window.renderMathInElement){
  try{ window.renderMathInElement(document.body, {delimiters: DELIMS, ignoredTags: IGNORE}); }catch(e){console.warn(e);}
  return;
}

injectCSS('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css');
injectJS('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js', () => {
  injectJS('https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js', () => {
    try{ window.renderMathInElement(document.body, {delimiters: DELIMS, ignoredTags: IGNORE}); }
    catch(e){ console.warn('katex render failed', e); }
  });
});
}

doRender();

let timer = null;
const obs = new MutationObserver((mutations) => {
let added=false;
for(const m of mutations){
if(m.addedNodes && m.addedNodes.length){ added=true; break; }
if(m.type==='characterData'){ added=true; break; }
}
if(!added) return;
if(timer) clearTimeout(timer);
timer = setTimeout(()=>{ doRender(); timer=null; }, 160);
});
obs.observe(document.documentElement||document.body, {childList:true, subtree:true, characterData:true});
})();
